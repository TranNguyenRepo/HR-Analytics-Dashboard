-- SQL code
-- Author: Tran Nguyen
-- Date: 2/8/2026
===========================================
---SELECTIVE COLUMNS THAT CAN BE USED---
-------- USE CTEs TO BUILD A VIEW-------
===========================================

CREATE OR REPLACE VIEW EMPLOYEE_DATA AS

WITH TEMP AS (
    SELECT 
        SYN_CLIENT_NAME, 
        SYN_COMPANY_GROUP, 
        CITY, 
        STATE, 
        COUNTRY, 
        SYN_EMPLOYEE_ID, 
        EMPLOYER_ID AS SYN_EMPLOYER_ID, 
        SYN_LOCATION_CODE, 
        POSITION_CODE_HOME,        
        POSITION_HOME, 
        EE_TYPE_CODE, 
        EE_TYPE, 
        EE_TYPE_CLASS_CODE, 
        EE_TYPE_CLASS, 
        EE_STATUS_CODE, 
        EE_STATUS, 
        SYNTHETIC_EMPLOYEE_NAME AS SYN_EMPLOYEE_NAME, 
        ORIGINAL_HIRE_DATE, 
        OLD_POSITION, 
        LAST_HIRE_DATE,
        NEW_POSITION, 
        EE_TERMINATION_DATE, 
        TERMINATION_REASON, 
        EMPLOYEE_POSITION, 
        POSITION_CODE_HOME_COM, 
        SYN_LOCATION_HOME_CODE AS SYN_FACILITY_HOME, 
        TERMINATION_TYPE
    FROM TURNOVER_DASHBOARD.PUBLIC.SYNTHETIC_EMPLOYEE_DATA
    WHERE ORIGINAL_HIRE_DATE >= '01/01/2020'
)

SELECT * 
FROM TEMP
WHERE 
    (
        EE_STATUS_CODE = 'A'
        AND EE_TERMINATION_DATE IS NULL
    )
    OR
    (
        EE_STATUS_CODE = 'L'
    )
    OR 
    (
        EE_STATUS_CODE = 'T'
        AND EE_TERMINATION_DATE IS NOT NULL
    ); -- data is not fully updated with EE_TERMINATION_DATE, we will remove those rows to avoid confusion

===========================================
--ADD AGGREGATION COLUMNS: TENURE---
===========================================

CREATE OR REPLACE VIEW EMPLOYEE_DATA_WT_TENURE_CAL AS

WITH TEMP AS (
    SELECT 
        SYN_CLIENT_NAME,
        SYN_COMPANY_GROUP, 
        CITY, 
        STATE, 
        COUNTRY, 
        SYN_EMPLOYEE_ID, 
        SYN_EMPLOYER_ID, 
        SYN_LOCATION_CODE, 
        POSITION_CODE_HOME, 
        POSITION_HOME,
        EE_TYPE_CODE, 
        EE_TYPE, 
        EE_TYPE_CLASS_CODE, 
        EE_TYPE_CLASS, 
        EE_STATUS_CODE, 
        EE_STATUS, 
        SYN_EMPLOYEE_NAME, 
        ORIGINAL_HIRE_DATE, 
        LAST_HIRE_DATE, 
        CASE 
            WHEN ORIGINAL_HIRE_DATE <> LAST_HIRE_DATE THEN LAST_HIRE_DATE 
            ELSE NULL 
        END AS TRANSFERRED_DATE, -- CREATE A 'TRANSFERRED_DATE' TO SEPARATE WITH LAST_HIRE_DATE TO AVOID CONFUSION
        NEW_POSITION,
        CASE 
            WHEN ORIGINAL_HIRE_DATE = LAST_HIRE_DATE THEN ORIGINAL_HIRE_DATE 
            ELSE NULL 
        END AS AS_IS_ORIGINAL_HIRE_DATE, 
        OLD_POSITION,
        EE_TERMINATION_DATE, 
        TERMINATION_REASON, 
        EMPLOYEE_POSITION, 
        POSITION_CODE_HOME_COM, 
        SYN_FACILITY_HOME, 
        TERMINATION_TYPE
    FROM TURNOVER_DASHBOARD.PUBLIC.EMPLOYEE_DATA
),

TENURE_CALCULATION AS (
    SELECT *,
        CASE
            WHEN EE_TERMINATION_DATE IS NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NOT NULL THEN 
                DATEDIFF(DAY, AS_IS_ORIGINAL_HIRE_DATE, CURRENT_DATE()) / 365
            WHEN EE_TERMINATION_DATE IS NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NULL THEN 
                DATEDIFF(DAY, TRANSFERRED_DATE, CURRENT_DATE()) / 365
            ELSE NULL 
        END AS ACTIVE_TENURE_IN_YEARS,
        CASE
            WHEN EE_TERMINATION_DATE IS NOT NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NOT NULL THEN 
                DATEDIFF(DAY, AS_IS_ORIGINAL_HIRE_DATE, EE_TERMINATION_DATE) / 365
            WHEN EE_TERMINATION_DATE IS NOT NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NULL THEN 
                DATEDIFF(DAY, TRANSFERRED_DATE, EE_TERMINATION_DATE) / 365
            ELSE NULL 
        END AS TERMED_TENURE_IN_YEARS
    FROM TEMP
),

STATIC_HEAD_COUNT AS (
    SELECT 
        -- TO CALCULATE THE HEADCOUNT THAT WILL NOT DYNAMICALLY CHANGE BY DATE FOR TURNOVER RATE PURPOSE
        COUNT(DISTINCT SYN_EMPLOYEE_NAME) AS HEADCOUNT
    FROM TENURE_CALCULATION
),
COMBINE_HEADCOUNT AS
(SELECT A.*, T.HEADCOUNT FROM tenure_calculation A
CROSS JOIN STATIC_HEAD_COUNT T
),
HIRED_WITHIN_LAST_MONTH AS
(
SELECT
  COUNT(DISTINCT SYN_EMPLOYEE_NAME) AS HIRED_WITHIN_LAST_MONTH
FROM COMBINE_HEADCOUNT
WHERE ORIGINAL_HIRE_DATE >= DATEADD(DAY, -30, CURRENT_DATE())
) 
, 
COMBINE AS
(SELECT A.*, T.HIRED_WITHIN_LAST_MONTH, ROUND((T.HIRED_WITHIN_LAST_MONTH/HEADCOUNT)*100,2) AS HIRED_INCREASE FROM COMBINE_HEADCOUNT A
CROSS JOIN HIRED_WITHIN_LAST_MONTH T),
MASTER_CALENDAR AS
(SELECT DISTINCT
    e.SYN_EMPLOYEE_NAME,
    TO_CHAR(DATEADD(month, g.VALUE, e.ORIGINAL_HIRE_DATE), 'YYYY-MM') AS YEAR_MONTH,
    YEAR(DATEADD(month, g.VALUE, e.ORIGINAL_HIRE_DATE)) AS CALENDAR_YEAR
FROM COMBINE e
JOIN TABLE(FLATTEN(ARRAY_GENERATE_RANGE(0, 
    DATEDIFF(month, e.ORIGINAL_HIRE_DATE, COALESCE(e.EE_TERMINATION_DATE, CURRENT_DATE())) + 1
))) g
),
FLAG AS (
    SELECT DISTINCT
        a.*,
        TO_DATE(t.YEAR_MONTH || '-01', 'YYYY-MM-DD') AS FULL_DATE,
        t.CALENDAR_YEAR,
        CASE
            WHEN EE_TERMINATION_DATE IS NULL 
                 AND DATE_TRUNC('MONTH', ORIGINAL_HIRE_DATE) = DATE_TRUNC('MONTH', FULL_DATE)
            THEN 1
            ELSE 0 
        END AS flag
    FROM COMBINE a
    JOIN MASTER_CALENDAR t
        ON t.SYN_EMPLOYEE_NAME = a.SYN_EMPLOYEE_NAME
)

SELECT DISTINCT *,
       ROW_NUMBER() OVER (
           PARTITION BY SYN_EMPLOYEE_NAME, FULL_DATE 
           ORDER BY SYN_EMPLOYEE_NAME, FULL_DATE
       ) AS DISTINCT_FLAG
FROM FLAG
QUALIFY DISTINCT_FLAG = 1;

===========================================
--CREATE MASTER CALENDAR--
===========================================
create or replace view TURNOVER_DASHBOARD.PUBLIC.MASTER_CALENDAR(
   CALENDAR_DATE,
   CALENDAR_YEAR,
   CALENDAR_QUARTER,
   CALENDAR_MONTH,
   CALENDAR_DAY,
   YEAR_MONTH,
   CALENDAR_WEEK,
   WEEKDAY_WEEKEND,
   CALENDAR_DATE_STR
) as
WITH RECURSIVE DATE_RANGE AS (
   -- Define start and end dates for your calendar
   SELECT DATE('1980-01-01') AS CALENDAR_DATE
   UNION ALL
   SELECT DATEADD(day, 1, CALENDAR_DATE)
   FROM DATE_RANGE
   WHERE CALENDAR_DATE < CURRENT_DATE  -- or use any end date like '2030-12-31'
)
SELECT
   CALENDAR_DATE,
   YEAR(CALENDAR_DATE) AS CALENDAR_YEAR,
   QUARTER(CALENDAR_DATE) AS CALENDAR_QUARTER,
   MONTH(CALENDAR_DATE) AS CALENDAR_MONTH,
   DAY(CALENDAR_DATE) AS CALENDAR_DAY,
   TO_CHAR(CALENDAR_DATE, 'YYYY-MM') AS YEAR_MONTH,
   WEEKOFYEAR(CALENDAR_DATE) AS CALENDAR_WEEK,
   CASE 
       WHEN DAYOFWEEK(CALENDAR_DATE) IN (1,7) THEN 'Weekend'
       ELSE 'Weekday'
   END AS WEEKDAY_WEEKEND,
   TO_CHAR(CALENDAR_DATE, 'YYYY-MM-DD') AS CALENDAR_DATE_STR
FROM DATE_RANGE
ORDER BY CALENDAR_DATE;

===========================================
--SEMANTIC ANALYS FOR WHY THEY LEAVE--
===========================================
ALTER ACCOUNT SET CORTEX_ENABLED_CROSS_REGION = 'ANY_REGION';

CREATE OR REPLACE VIEW TURNOVER_DASHBOARD.PUBLIC.EXIT_SURVEY_ANALYSIS
AS
WITH TEMP AS (
    SELECT DISTINCT 
        ID, 
        COMPLETION_DATE, 
        EMAIL, 
        SYN_COMPANY_NAME, 
        LOCATION, 
        SYN_FIRST_NAME, 
        SYN_LAST_NAME, 
        POSITION, 
        SYN_SUPERVISOR_NAME, 
        WHAT_IS_THE_REASON_THAT_MADE_YOU_DECIDE_TO_LEAVE,
        TRIM(f.value) AS REASON_TO_LEAVE,  -- each reason as a separate row
        PLEASE_RATE_THE_LEADERSHIP_QUALITIES_OF_UPPER_MANAGEMENT_LOCAL_AND_CORPORATE, 
        COMMENTS_TO_QUESTION_12,
        REASON,
        REASON_GROUP
    FROM EXIT_SURVEY,
    LATERAL SPLIT_TO_TABLE(WHAT_IS_THE_REASON_THAT_MADE_YOU_DECIDE_TO_LEAVE, ';') f
)
SELECT *,
        round(SNOWFLAKE.CORTEX.SENTIMENT(COMMENTS_TO_QUESTION_12),2) AS COMMENTS_SENTIMENT_SCORE

FROM TEMP
WHERE LENGTH(REASON_TO_LEAVE) >= 1 -- REMOVE NULL VALUE 
order by SYN_FIRST_NAME, SYN_LAST_NAME;


SELECT * FROM TURNOVER_DASHBOARD.PUBLIC.EXIT_SURVEY_ANALYSIS;
