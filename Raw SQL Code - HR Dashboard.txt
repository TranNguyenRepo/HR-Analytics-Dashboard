--create or replace database TURNOVER_DASHBOARD;
-- 
-- Author: Tran Nguyen
-- Date: 2/8/2026
-- Preprocess data
-- 1. Check dataset
ALTER TABLE TURNOVER_DASHBOARD.PUBLIC.SYNTHETIC_EMPLOYEE_DATA
ADD COLUMN COUNTRY STRING;
UPDATE TURNOVER_DASHBOARD.PUBLIC.SYNTHETIC_EMPLOYEE_DATA
SET  YEAR(ORIGINAL_HIRE_DATE_CLEANED) = 2020 
WHERE YEAR(ORIGINAL_HIRE_DATE_CLEANED) <=2020;




select * from TURNOVER_DASHBOARD.PUBLIC.SYNTHETIC_EMPLOYEE_DATA;
--
-- Data Information
-- ORIGINAL HIRE DATE: is column when employee first hired with
-- LAST HIRE DATE: is a column when employee transferred to another position/dept or equal ORIGINAL HIRE DATE if they never transfer
-- SYN_CLIENT_NAME, SYN_EMPLOYEE_ID: all employee names are synthetic, not real
----------------------------------------
---SELECTIVE COLUMNS THAT CAN BE USED---
-------- USE CTEs TO BUILD A VIEW-------
----------------------------------------
CREATE OR REPLACE VIEW EMPLOYEE_DATA AS
with temp as 
(select SYN_CLIENT_NAME, SYN_COMPANY_GROUP, CITY, STATE, COUNTRY, SYN_EMPLOYEE_ID, EMPLOYER_ID as SYN_EMPLOYER_ID, SYN_LOCATION_CODE, POSITION_CODE_HOME, POSITION_HOME, EE_TYPE_CODE, EE_TYPE, EE_TYPE_CLASS_CODE, EE_TYPE_CLASS, EE_STATUS_CODE, EE_STATUS, SYNTHETIC_EMPLOYEE_NAME as SYN_EMPLOYEE_NAME, ORIGINAL_HIRE_DATE, OLD_POSITION, LAST_HIRE_DATE,NEW_POSITION, EE_TERMINATION_DATE, TERMINATION_REASON, EMPLOYEE_POSITION, POSITION_CODE_HOME_COM, SYN_LOCATION_HOME_CODE as SYN_FACILITY_HOME, TERMINATION_TYPE from TURNOVER_DASHBOARD.PUBLIC.SYNTHETIC_EMPLOYEE_DATA
where ORIGINAL_HIRE_DATE >= '01/01/2020')
select * from temp
WHERE 
(
    EE_STATUS_CODE = 'A'
    AND EE_TERMINATION_DATE IS NULL
)
OR
(
    EE_STATUS_CODE = 'L'
)
OR 
(
    EE_STATUS_CODE = 'T'
    AND EE_TERMINATION_DATE IS NOT NULL
);
 -- data is not fully updated with EE_TERMINATION_DATE, we will remove those rows to avoid confusion
------------------------------------------------
---------test data again------------------------
------------------------------------------------
select * from EMPLOYEE_DATA
where SYN_EMPLOYEE_NAME LIKE '%Chelsea Krueger%';
----------------------------------------
---SELECTIVE COLUMNS THAT CAN BE USED---
--------CHECK IF ORIGINAL HIRE DATE != LAST HIRE DATE WHEN TERMINATION IS NULL > CREATE TRANSFERRED DATE COLUMNS-------
----------------------------------------
CREATE OR REPLACE VIEW EMPLOYEE_DATA_WT_TENURE_CAL 
AS
WITH TEMP AS
(select SYN_CLIENT_NAME,SYN_COMPANY_GROUP, CITY, STATE, COUNTRY, SYN_EMPLOYEE_ID, SYN_EMPLOYER_ID, SYN_LOCATION_CODE, POSITION_CODE_HOME, POSITION_HOME, EE_TYPE_CODE, EE_TYPE, EE_TYPE_CLASS_CODE, EE_TYPE_CLASS, EE_STATUS_CODE, EE_STATUS, SYN_EMPLOYEE_NAME, ORIGINAL_HIRE_DATE, LAST_HIRE_DATE, 
CASE 
    WHEN ORIGINAL_HIRE_DATE <> LAST_HIRE_DATE THEN LAST_HIRE_DATE 
    ELSE NULL END AS TRANSFERRED_DATE, -- CREATE A 'TRANSFERRED_DATE' TO SEPARATE WITH LAST_HIRE_DATE TO AVOID CONFUSION
NEW_POSITION,
CASE 
    WHEN ORIGINAL_HIRE_DATE = LAST_HIRE_DATE THEN ORIGINAL_HIRE_DATE 
    ELSE NULL END AS AS_IS_ORIGINAL_HIRE_DATE, 
OLD_POSITION,
EE_TERMINATION_DATE, TERMINATION_REASON, EMPLOYEE_POSITION, POSITION_CODE_HOME_COM, SYN_FACILITY_HOME, 
TERMINATION_TYPE
from TURNOVER_DASHBOARD.PUBLIC.EMPLOYEE_DATA)
, 
tenure_calculation as
(SELECT *,
CASE
    WHEN EE_TERMINATION_DATE IS NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NOT NULL THEN DATEDIFF(DAY,AS_IS_ORIGINAL_HIRE_DATE ,CURRENT_DATE())/365
    WHEN EE_TERMINATION_DATE IS NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NULL THEN DATEDIFF(DAY,TRANSFERRED_DATE,  CURRENT_DATE())/365
    ELSE NULL END AS ACTIVE_TENURE_IN_YEARS,
CASE
    WHEN EE_TERMINATION_DATE IS NOT NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NOT NULL THEN DATEDIFF(DAY,AS_IS_ORIGINAL_HIRE_DATE,EE_TERMINATION_DATE)/365
    WHEN EE_TERMINATION_DATE IS NOT NULL AND AS_IS_ORIGINAL_HIRE_DATE IS NULL  THEN DATEDIFF(DAY,TRANSFERRED_DATE,EE_TERMINATION_DATE)/365
    ELSE NULL END AS TERMED_TENURE_IN_YEARS
FROM TEMP),
STATIC_HEAD_COUNT as
(SELECT 
-- TO CALCULATE THE HEADCOUNT THAT WILL NOT DYNAMICALLY CHANGE BY DATE FOR TURNOVER RATE PURPOSE
COUNT(DISTINCT SYN_EMPLOYEE_NAME) AS HEADCOUNT
FROM tenure_calculation) 
, 
COMBINE_HEADCOUNT AS
(SELECT A.*, T.HEADCOUNT FROM tenure_calculation A
CROSS JOIN STATIC_HEAD_COUNT T
),
HIRED_WITHIN_LAST_MONTH AS
(
SELECT
  COUNT(DISTINCT SYN_EMPLOYEE_NAME) AS HIRED_WITHIN_LAST_MONTH
FROM COMBINE_HEADCOUNT
WHERE ORIGINAL_HIRE_DATE >= DATEADD(DAY, -30, CURRENT_DATE())
) 
, 
COMBINE AS
(SELECT A.*, T.HIRED_WITHIN_LAST_MONTH, ROUND((T.HIRED_WITHIN_LAST_MONTH/HEADCOUNT)*100,2) AS HIRED_INCREASE FROM COMBINE_HEADCOUNT A
CROSS JOIN HIRED_WITHIN_LAST_MONTH T),
MASTER_CALENDAR AS
(SELECT DISTINCT
    e.SYN_EMPLOYEE_NAME,
    TO_CHAR(DATEADD(month, g.VALUE, e.ORIGINAL_HIRE_DATE), 'YYYY-MM') AS YEAR_MONTH,
    YEAR(DATEADD(month, g.VALUE, e.ORIGINAL_HIRE_DATE)) AS CALENDAR_YEAR
FROM COMBINE e
JOIN TABLE(FLATTEN(ARRAY_GENERATE_RANGE(0, 
    DATEDIFF(month, e.ORIGINAL_HIRE_DATE, COALESCE(e.EE_TERMINATION_DATE, CURRENT_DATE())) + 1
))) g
),
FLAG AS

(SELECT DISTINCT
    a.*,
    TO_DATE(t.YEAR_MONTH || '-01', 'YYYY-MM-DD') AS FULL_DATE,
    t.CALENDAR_YEAR,
    -- ROW_NUMBER() OVER (
    --     PARTITION BY a.SYN_EMPLOYEE_NAME, t.CALENDAR_YEAR 
    --     ORDER BY a.SYN_EMPLOYEE_NAME, t.CALENDAR_YEAR 
    --     -- TO_DATE(t.YEAR_MONTH || '-01', 'YYYY-MM-DD') DESC
    -- ) AS CENSUS_PER_YEAR,
      CASE
    WHEN EE_TERMINATION_DATE IS NULL AND 
    DATE_TRUNC('MONTH', ORIGINAL_HIRE_DATE) = DATE_TRUNC('MONTH', FULL_DATE)
    THEN 1
    -- WHEN EE_TERMINATION_DATE IS NULL AND 
    -- DATE_TRUNC('MONTH', ORIGINAL_HIRE_DATE) != DATE_TRUNC('MONTH', FULL_DATE)
    -- THEN 0
    ELSE 0
  END AS flag
FROM COMBINE a
JOIN MASTER_CALENDAR t
    ON t.SYN_EMPLOYEE_NAME = a.SYN_EMPLOYEE_NAME)
SELECT DISTINCT *,
ROW_NUMBER() OVER (PARTITION BY SYN_EMPLOYEE_NAME, FULL_DATE ORDER BY SYN_EMPLOYEE_NAME, FULL_DATE) AS DISTINCT_FLAG
FROM FLAG
QUALIFY DISTINCT_FLAG = 1 
;




SELECT DISTINCT *
FROM TURNOVER_DASHBOARD.PUBLIC.EMPLOYEE_DATA_WT_TENURE_CAL;
WHERE SYN_EMPLOYEE_NAME ='Adam Jones'
ORDER BY FULL_DATE;
--------------------------------------------------------------------------------------------
----------------------------CREATE MASTER CALENDAR-------------------------------------
--------------------------------------------------------------------------------------------
create or replace view TURNOVER_DASHBOARD.PUBLIC.MASTER_CALENDAR(
   CALENDAR_DATE,
   CALENDAR_YEAR,
   CALENDAR_QUARTER,
   CALENDAR_MONTH,
   CALENDAR_DAY,
   YEAR_MONTH,
   CALENDAR_WEEK,
   WEEKDAY_WEEKEND,
   CALENDAR_DATE_STR
) as
WITH RECURSIVE DATE_RANGE AS (
   -- Define start and end dates for your calendar
   SELECT DATE('1980-01-01') AS CALENDAR_DATE
   UNION ALL
   SELECT DATEADD(day, 1, CALENDAR_DATE)
   FROM DATE_RANGE
   WHERE CALENDAR_DATE < CURRENT_DATE  -- or use any end date like '2030-12-31'
)
SELECT
   CALENDAR_DATE,
   YEAR(CALENDAR_DATE) AS CALENDAR_YEAR,
   QUARTER(CALENDAR_DATE) AS CALENDAR_QUARTER,
   MONTH(CALENDAR_DATE) AS CALENDAR_MONTH,
   DAY(CALENDAR_DATE) AS CALENDAR_DAY,
   TO_CHAR(CALENDAR_DATE, 'YYYY-MM') AS YEAR_MONTH,
   WEEKOFYEAR(CALENDAR_DATE) AS CALENDAR_WEEK,
   CASE 
       WHEN DAYOFWEEK(CALENDAR_DATE) IN (1,7) THEN 'Weekend'
       ELSE 'Weekday'
   END AS WEEKDAY_WEEKEND,
   TO_CHAR(CALENDAR_DATE, 'YYYY-MM-DD') AS CALENDAR_DATE_STR
FROM DATE_RANGE
ORDER BY CALENDAR_DATE;

SELECT * FROM MASTER_CALENDAR;

select * from EMPLOYEE_DATA_WT_TENURE_CAL;
------------MAP MASTER CALENDAR
WITH TEMP AS
(SELECT distinct
    e.SYN_EMPLOYEE_NAME,
    TO_CHAR(DATEADD(month, g.VALUE, e.ORIGINAL_HIRE_DATE), 'YYYY-MM') AS YEAR_MONTH
FROM TURNOVER_DASHBOARD.PUBLIC.EMPLOYEE_DATA_WT_TENURE_CAL e
JOIN TABLE(FLATTEN(ARRAY_GENERATE_RANGE(0, 
    DATEDIFF(month, e.ORIGINAL_HIRE_DATE, COALESCE(e.EE_TERMINATION_DATE, CURRENT_DATE())) + 1
))) g
ORDER BY e.SYN_EMPLOYEE_NAME, YEAR_MONTH) 
SELECT DISTINCT a.*, t.YEAR_MONTH 
FROM TURNOVER_DASHBOARD.PUBLIC.EMPLOYEE_DATA_WT_TENURE_CAL a
JOIN TEMP t
ON t.SYN_EMPLOYEE_NAME = a.SYN_EMPLOYEE_NAME;




CROSS JOIN MASTER_CALENDAR t;

--------------------------------------------------------------------------------------------
-------------------------SEMANTIC ANALYS FOR WHY THEY LEAVE---------------------------------
--------------------------------------------------------------------------------------------
-- check dataset
-- The dataset has only 15 entries
-- with the question WHAT IS THE REASON THAT MADE YOU DECIDE TO LEAVE: that is a multiple choice question, will need to break each reason down by using FLATTEN()
-- Using Snowflake Cortex (LLM) to score the column COMMENTS TO QUESTION 12: "PLEASE_RATE_THE_LEADERSHIP_QUALITIES_OF_UPPER_MANAGEMENT_LOCAL_AND_CORPORATE" to evaluate the leadership quality and if they leave because of the leadership
-- I am using US EAST OHIO >> need to set up CORTEX
ALTER ACCOUNT SET CORTEX_ENABLED_CROSS_REGION = 'ANY_REGION';

---REPLACE PROPER NAME TO COMMON NOUN---
UPDATE TURNOVER_DASHBOARD.PUBLIC.EXIT_SURVEY
SET COMMENTS_TO_QUESTION_12 =
    REGEXP_REPLACE(
        COMMENTS_TO_QUESTION_12,
        '(?i)\\bjessica\\b',
        'supervisor'
    )
WHERE COMMENTS_TO_QUESTION_12 ILIKE '%jessica%';

-----------------------------------------------------------------------------------
--CREATE EXIT SURVEY ANALYSIS WITH SNOWFLAKE CORTEX TO SCORE THE SURVEYER'S COMMENT SENTIMENT--
-----------------------------------------------------------------------------------
CREATE OR REPLACE VIEW TURNOVER_DASHBOARD.PUBLIC.EXIT_SURVEY_ANALYSIS
AS
WITH TEMP AS (
    SELECT DISTINCT 
        ID, 
        COMPLETION_DATE, 
        EMAIL, 
        SYN_COMPANY_NAME, 
        LOCATION, 
        SYN_FIRST_NAME, 
        SYN_LAST_NAME, 
        POSITION, 
        SYN_SUPERVISOR_NAME, 
        WHAT_IS_THE_REASON_THAT_MADE_YOU_DECIDE_TO_LEAVE,
        TRIM(f.value) AS REASON_TO_LEAVE,  -- each reason as a separate row
        PLEASE_RATE_THE_LEADERSHIP_QUALITIES_OF_UPPER_MANAGEMENT_LOCAL_AND_CORPORATE, 
        COMMENTS_TO_QUESTION_12,
        REASON,
        REASON_GROUP
    FROM EXIT_SURVEY,
    LATERAL SPLIT_TO_TABLE(WHAT_IS_THE_REASON_THAT_MADE_YOU_DECIDE_TO_LEAVE, ';') f
)
SELECT *,
        round(SNOWFLAKE.CORTEX.SENTIMENT(COMMENTS_TO_QUESTION_12),2) AS COMMENTS_SENTIMENT_SCORE

FROM TEMP
WHERE LENGTH(REASON_TO_LEAVE) >= 1 -- REMOVE NULL VALUE 
order by SYN_FIRST_NAME, SYN_LAST_NAME;


SELECT * FROM TURNOVER_DASHBOARD.PUBLIC.EXIT_SURVEY_ANALYSIS;